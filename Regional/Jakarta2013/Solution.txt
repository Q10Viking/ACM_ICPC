A：排序之后，dp[i][j]表示前i个，分成j堆，O(n ^ 3)。

B：由于d很小，而t[]都是不相同的，所以每次可以转移的并不多。dp[i][j]表示b[i]排在a[j]前面有多少种。空间上可以滚动，转移的话b[i]能排在a[]前面最多2 * d个，所以总时间是O(n * d)

C：树DP

D：先把特殊点合并到集合，然后做最小生成树

E：对偶图上的最长路。。。我不会图论啊


F：贪心，肯定前缀和后缀匹配的越短越好。所以每次枚举匹配的长度，从小到大，只要匹配了，肯定就把头尾切掉，继续匹配。判断匹配的话使用HASH就好了，所以只需要枚举一遍，O(n)

G：斜率K的范围是0-100，所以对于每个斜率搞一个优先队列

H：dp，每次dp最大最小进行转移

I：二分答案，然后对于每一个点都有一个可移动到的区间，根据间隔判断区间是否有交：

J：很简单的线段树题。。。看了图以为是个很复杂的数学题。。。。给出一些三次函数，然后求区间的y值和。只取横坐标为整数的点。
三次函数的4部分求和是完全独立的，所以分开维护就好了。。