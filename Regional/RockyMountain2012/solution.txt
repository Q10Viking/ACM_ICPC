A：直接贪心，小心爆int

B：一看就很难写的无聊题。。。我很懒的

C：我们把区间里的合数筛选掉，所以枚举素数作为因子
那么(a * n + b) % p == 0，说明是合数
那么a * x - p * y = b，变成了A * x + B * y = C的形式求解
方程解了，然后暴力枚举范围内的y把合数筛选掉就好了
注意一些特殊情况，比如gcd (a , b) > 1，那么n >= 1的时候肯定为合数，只需要处理l = 0的情况
另外需要注意的是0 , 1都是合数，但是不存在 > 2的因子，所以要特殊处理掉
其实就是把n <= 1的情况处理掉，只有n <= 1，a * n + b 才有可能小于2

D：似乎老掉牙了，但是一脸不会做的样子，对于每个站求差值，然后搞出前缀和，前缀和最小的就是限制这条路径的，最小值非负说明可达。
那么不断枚举起点，然后维护最小值就可以了，O(n)

E：状态压缩DP，从后往前dp，先放序列的后面，这样方便之后的路径输出，方便路径字典序最小。
对于现有的状态i，然后把点j加到前面，每加个点，处理j和在j之前的点的代价，其实随便按什么方式统计啦。。。反正就是这个点加在这个位置的代价
然后字典序最小，直接从起点开始枚举，保证dp[]最优值可以等价转移，说明可达。发现这种方式挺好，之前总是想着在转移的时候保存路径，太麻烦

F：长沙的热身赛题，当时写得很纠结的样子，反正就是暴力，注意字典序就好了

G：一看就不想做的样子

H：并查集直接维护，出现环的话就标记一下这个集合。直接对每个连通块DFS也可以。

I：比较简单的几何，直接枚举时间点，然后就是一条射线或者线段与圆求交。注意一下圆心在某个圆内的情况，要特殊处理。

J：优化队列维护医生的情况。对于取出的一个医生，直接枚举所有病人，取出优先级最大的。
注意两点，对于每个病人，不能分身去多项治疗，所以要维护这个病人到达医院或者上次治疗完的时间
对于已经在等待室中的病人，直接取出优化级最大，相同则取到达时间最早的
如果当前没有人在等待，那么就取最早来等待，相同则按上条规则。
总之就是暴力！！！
