A : n ^ 2的DP，将可以作为起点的最高点标为1，然后按高度递减顺序来DP，最后统计一下可以作为终点的最低点的值。

B : 先统计边权和，然后对于每个节点的邻接边权和sum以及边权最大值max，我们当然希望这些边权能够两两配对，这样就可以省下来了。那么对于max * 2 <= sum的情况，说明肯定能两两配对(当然奇数的情况除外)，否则的话，只能其它边和max来匹配，最终节省的是sum - max条。

C : 很容易发现(A_i + B_i + C_i + D_i + E_i) = 2 * (A_{i - 1} + B_{i - 1} + C_{i - 1} + D_{i - 1} + E_{i - 1})
所以统计和，每次都是两倍扩展，那么log暴力下就好了。注意一下初始状态，以及无解的情况。

D : Kd-tree

E : DP，dp[i][j]表示第i个移到到位置j，而且保证能够登上i的最小价值。那么从左到右，从右到左分别DP一下就好了。注意一些细节，比如说直接能从地面上的，以及最高塔不能移动(其实这个无所谓？)

F : 看上去巨神

G : 双连通分量。将双连通分量(顶点个数>1)里的点去掉之后，形成若干个连通块，那么这些连通块内部两两是满足要求的。

H : 注意只会有5W个点被修改，所以就是暴力查找和修改了。曼哈顿距离 <= D，显然就是那个经典的做法，旋转45度之后，然后用set维护。可以在set上暴力，似乎可以卡过。如果用个线段树查询的话，会快好多。

I : 猜了下，行列是有循环节的，那么我们考虑循环节 * 循环节里的情况，肯定有循环节个点，那么大胆猜想答案就是循环节。TAT。。。但是为什么我暴力用扩展欧几里德求1W组解然后取GCD是错的，而且结果偏小，不能理解。

J : 暴力枚举，然后HASH判断一下